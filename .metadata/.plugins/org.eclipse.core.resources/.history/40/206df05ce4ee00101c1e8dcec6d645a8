/*
 * ssd1306.c
 *
 *  Created on: Jan 11, 2026
 *      Author: sreer
 */


#include "ssd1306.h"

extern I2C_HandleTypeDef hi2c1; // Linked to your main.c
static uint8_t SSD1306_Buffer[SSD1306_WIDTH * SSD1306_HEIGHT / 8];

static void ssd1306_WriteCommand(uint8_t byte) {
    HAL_I2C_Mem_Write(&hi2c1, SSD1306_I2C_ADDR, 0x00, 1, &byte, 1, HAL_MAX_DELAY);
}

uint8_t ssd1306_Init(void) {
    HAL_Delay(100); // Wait for screen to power up

    ssd1306_WriteCommand(0xAE); // Display Off
    ssd1306_WriteCommand(0x20); // Set Memory Addressing Mode
    ssd1306_WriteCommand(0x10); // Page Addressing Mode
    ssd1306_WriteCommand(0xB0); // Set Page Start Address for Page Addressing Mode
    ssd1306_WriteCommand(0xC8); // Set COM Output Scan Direction
    ssd1306_WriteCommand(0x00); // Set low column address
    ssd1306_WriteCommand(0x10); // Set high column address
    ssd1306_WriteCommand(0x40); // Set start line address
    ssd1306_WriteCommand(0x81); // Set contrast control register
    ssd1306_WriteCommand(0xFF);
    ssd1306_WriteCommand(0xA1); // Set segment re-map 0 to 127
    ssd1306_WriteCommand(0xA6); // Set normal display
    ssd1306_WriteCommand(0xA8); // Set multiplex ratio(1 to 64)
    ssd1306_WriteCommand(0x1F); // 1/32 duty (FOR 128x32)
    ssd1306_WriteCommand(0xA4); // 0xa4,Output follows RAM content;0xa5,Output ignores RAM content
    ssd1306_WriteCommand(0xD3); // Set display offset
    ssd1306_WriteCommand(0x00); // No offset
    ssd1306_WriteCommand(0xD5); // Set display clock divide ratio/oscillator frequency
    ssd1306_WriteCommand(0xF0); // Set divide ratio
    ssd1306_WriteCommand(0xD9); // Set pre-charge period
    ssd1306_WriteCommand(0x22);
    ssd1306_WriteCommand(0xDA); // Set com pins hardware configuration
    ssd1306_WriteCommand(0x02); // 0x02 for 128x32
    ssd1306_WriteCommand(0xDB); // Set vcomh
    ssd1306_WriteCommand(0x20); // 0x20,0.77xVcc
    ssd1306_WriteCommand(0x8D); // Set DC-DC enable
    ssd1306_WriteCommand(0x14);
    ssd1306_WriteCommand(0xAF); // Display On

    ssd1306_Fill(Black);
    ssd1306_UpdateScreen();
    return 0;
}

void ssd1306_Fill(SSD1306_COLOR color) {
    memset(SSD1306_Buffer, (color == Black) ? 0x00 : 0xFF, sizeof(SSD1306_Buffer));
}

void ssd1306_UpdateScreen(void) {
    for (uint8_t i = 0; i < 4; i++) {
        ssd1306_WriteCommand(0xB0 + i);
        ssd1306_WriteCommand(0x00);
        ssd1306_WriteCommand(0x10);
        HAL_I2C_Mem_Write(&hi2c1, SSD1306_I2C_ADDR, 0x40, 1, &SSD1306_Buffer[SSD1306_WIDTH * i], SSD1306_WIDTH, HAL_MAX_DELAY);
    }
}

// Internal cursor position
static uint8_t CurrentX = 0;
static uint8_t CurrentY = 0;

void ssd1306_SetCursor(uint8_t x, uint8_t y) {
    CurrentX = x;
    CurrentY = y;
}

char ssd1306_WriteChar(char ch, FontDef Font, SSD1306_COLOR color) {
    if (ch < 32 || ch > 126) return 0;
    if (SSD1306_WIDTH < (CurrentX + Font.width) || SSD1306_HEIGHT < (CurrentY + Font.height)) return 0;

    for (uint8_t i = 0; i < Font.height; i++) {
        uint16_t b = Font.data[(ch - 32) * Font.height + i];
        for (uint8_t j = 0; j < Font.width; j++) {
            if ((b << j) & 0x8000) {
                // Set pixel
                uint16_t idx = CurrentX + j + (uint16_t)((CurrentY + i) / 8) * SSD1306_WIDTH;
                if (color == White) SSD1306_Buffer[idx] |= (1 << ((CurrentY + i) % 8));
                else SSD1306_Buffer[idx] &= ~(1 << ((CurrentY + i) % 8));
            }
        }
    }
    CurrentX += Font.width;
    return ch;
}

char ssd1306_WriteString(char* str, FontDef Font, SSD1306_COLOR color) {
    while (*str) {
        if (ssd1306_WriteChar(*str, Font, color) != *str) return *str;
        str++;
    }
    return *str;
}
