/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN TD */

/* USER CODE END TD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN Define */

/* USER CODE END Define */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN Macro */

/* USER CODE END Macro */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */
// Simple print function
void print_string(const char *str) {
    HAL_UART_Transmit(&huart2, (uint8_t*)str, strlen(str), HAL_MAX_DELAY);
}

// Simple print integer
void print_int(int value) {
    char buffer[12];
    sprintf(buffer, "%d", value);
    print_string(buffer);
}

// Simple print float (2 decimal places)
void print_float(float value) {
    int integer = (int)value;
    int decimal = (int)((value - integer) * 100);
    if(decimal < 0) decimal = -decimal;

    char buffer[20];
    sprintf(buffer, "%d.%02d", integer, decimal);
    print_string(buffer);
}

// Print hex value
void print_hex(uint32_t value, int digits) {
    char buffer[10];
    sprintf(buffer, "%0*lX", digits, value);
    print_string(buffer);
}

uint8_t sgp40_initialized = 0;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN PFP */

// Read SHT41 Temperature and Humidity
HAL_StatusTypeDef SHT41_Read(float *temperature, float *humidity) {
    uint8_t cmd = SHT41_MEAS_HIGH_PRECISION;
    uint8_t data[6];

    // Send measurement command
    if(HAL_I2C_Master_Transmit(&hi2c1, SHT41_ADDR << 1, &cmd, 1, 100) != HAL_OK) {
        return HAL_ERROR;
    }

    // Wait for measurement
    HAL_Delay(10);

    // Read 6 bytes of data
    if(HAL_I2C_Master_Receive(&hi2c1, SHT41_ADDR << 1, data, 6, 100) != HAL_OK) {
        return HAL_ERROR;
    }

    // Convert temperature (first 2 bytes)
    uint16_t temp_raw = (data[0] << 8) | data[1];
    *temperature = -45.0f + (175.0f * temp_raw) / 65535.0f;

    // Convert humidity (bytes 3-4)
    uint16_t hum_raw = (data[3] << 8) | data[4];
    *humidity = -6.0f + (125.0f * hum_raw) / 65535.0f;

    // Clamp humidity
    if(*humidity < 0.0f) *humidity = 0.0f;
    if(*humidity > 100.0f) *humidity = 100.0f;

    return HAL_OK;
}

// COMPLETE SGP40 TEST SUITE
void SGP40_CompleteTest(void) {
    uint8_t cmd[2];
    uint8_t data[10];
    HAL_StatusTypeDef status;

    print_string("\r\n=== SGP40 COMPLETE TEST ===\r\n");

    // Test 1: Check if device responds to ACK
    print_string("1. Device ACK Test... ");
    if(HAL_I2C_IsDeviceReady(&hi2c1, SGP40_ADDR << 1, 3, 100) == HAL_OK) {
        print_string("OK (Device ACKs)\r\n");
    } else {
        print_string("FAILED (No ACK)\r\n");
        return;
    }

    // Test 2: Try General Call Reset (address 0x00)
    print_string("2. General Call Reset (0x00)... ");
    uint8_t general_reset[2] = {0x06, 0x00};  // General call reset
    status = HAL_I2C_Master_Transmit(&hi2c1, 0x00, general_reset, 2, 100);
    if(status == HAL_OK) {
        print_string("Sent\r\n");
    } else {
        print_string("Failed (");
        print_int(status);
        print_string(")\r\n");
    }
    HAL_Delay(100);

    // Test 3: Try Soft Reset at correct address
    print_string("3. Soft Reset (0x59)... ");
    cmd[0] = 0x00;  // Soft reset MSB
    cmd[1] = 0x06;  // Soft reset LSB

    // Try with STOP condition
    hi2c1.Instance->CR1 |= I2C_CR1_STOP;
    while(hi2c1.Instance->SR2 & I2C_SR2_BUSY);

    status = HAL_I2C_Master_Transmit(&hi2c1, SGP40_ADDR << 1, cmd, 2, 100);
    if(status == HAL_OK) {
        print_string("OK\r\n");
    } else {
        print_string("FAILED (Status: ");
        print_int(status);
        print_string(")\r\n");
    }
    HAL_Delay(100);

    // Test 4: Try to read something back (soft reset doesn't return data)
    print_string("4. Try Read after reset... ");
    status = HAL_I2C_Master_Receive(&hi2c1, SGP40_ADDR << 1, data, 1, 50);
    if(status == HAL_OK) {
        print_string("Got: 0x");
        print_hex(data[0], 2);
        print_string(" (Unexpected!)\r\n");
    } else {
        print_string("No response (Expected)\r\n");
    }

    // Test 5: Try Get Features command (0x202F)
    print_string("5. Get Features (0x202F)... ");
    cmd[0] = 0x20;
    cmd[1] = 0x2F;
    status = HAL_I2C_Master_Transmit(&hi2c1, SGP40_ADDR << 1, cmd, 2, 100);
    if(status == HAL_OK) {
        print_string("TX OK, ");
        HAL_Delay(10);
        status = HAL_I2C_Master_Receive(&hi2c1, SGP40_ADDR << 1, data, 3, 100);
        if(status == HAL_OK) {
            print_string("RX OK: ");
            print_hex(data[0], 2);
            print_string(" ");
            print_hex(data[1], 2);
            print_string(" CRC:");
            print_hex(data[2], 2);
            print_string("\r\n");
        } else {
            print_string("RX FAILED\r\n");
        }
    } else {
        print_string("TX FAILED\r\n");
    }

    // Test 6: Try Measure Raw (without compensation)
    print_string("6. Measure Raw (0x260F)... ");
    cmd[0] = 0x26;
    cmd[1] = 0x0F;

    // Send command
    status = HAL_I2C_Master_Transmit(&hi2c1, SGP40_ADDR << 1, cmd, 2, 100);
    if(status == HAL_OK) {
        print_string("TX OK, ");
        HAL_Delay(50);  // Wait for measurement

        // Try to read with different approaches

        // Approach 1: Standard read
        status = HAL_I2C_Master_Receive(&hi2c1, SGP40_ADDR << 1, data, 3, 100);
        if(status == HAL_OK) {
            uint16_t raw_value = (data[0] << 8) | data[1];
            print_string("RX OK: Raw=");
            print_int(raw_value);
            print_string(" CRC:0x");
            print_hex(data[2], 2);
            print_string("\r\n");

            if(raw_value > 0 && raw_value != 0xFFFF && raw_value != 0xD400) {
                sgp40_initialized = 1;
                print_string("SGP40 WORKING!\r\n");
            }
        } else {
            print_string("RX FAILED (");
            print_int(status);
            print_string(")\r\n");

            // Try approach 2: Generate STOP and retry
            print_string("   Retry with STOP... ");
            hi2c1.Instance->CR1 |= I2C_CR1_STOP;
            while(hi2c1.Instance->SR2 & I2C_SR2_BUSY);
            HAL_Delay(10);

            status = HAL_I2C_Master_Receive(&hi2c1, SGP40_ADDR << 1, data, 3, 100);
            if(status == HAL_OK) {
                print_string("OK on retry\r\n");
                sgp40_initialized = 1;
            } else {
                print_string("FAILED on retry\r\n");
            }
        }
    } else {
        print_string("TX FAILED\r\n");
    }

    // Test 7: Try Heater Off command
    print_string("7. Heater Off (0x3615)... ");
    cmd[0] = 0x36;
    cmd[1] = 0x15;
    status = HAL_I2C_Master_Transmit(&hi2c1, SGP40_ADDR << 1, cmd, 2, 100);
    if(status == HAL_OK) {
        print_string("OK\r\n");
    } else {
        print_string("FAILED\r\n");
    }

    print_string("=== TEST COMPLETE ===\r\n\r\n");
}

// Simple SGP40 read (if initialized)
HAL_StatusTypeDef SGP40_ReadRaw(uint16_t *raw_value) {
    uint8_t cmd[2] = {0x26, 0x0F};
    uint8_t data[3];

    if(!sgp40_initialized) {
        return HAL_ERROR;
    }

    // Send command
    if(HAL_I2C_Master_Transmit(&hi2c1, SGP40_ADDR << 1, cmd, 2, 100) != HAL_OK) {
        return HAL_ERROR;
    }

    HAL_Delay(50);

    // Read result
    if(HAL_I2C_Master_Receive(&hi2c1, SGP40_ADDR << 1, data, 3, 100) != HAL_OK) {
        return HAL_ERROR;
    }

    *raw_value = (data[0] << 8) | data[1];

    // Basic validation
    if(*raw_value == 0xFFFF || *raw_value == 0x0000 || *raw_value == 0xD400) {
        return HAL_ERROR;
    }

    return HAL_OK;
}

// I2C Scanner
void I2C_Scan(void) {
    uint8_t i, found = 0;

    print_string("I2C Scan: ");

    for(i = 1; i < 128; i++) {
        if(HAL_I2C_IsDeviceReady(&hi2c1, i << 1, 1, 10) == HAL_OK) {
            if(found > 0) print_string(", ");
            print_string("0x");
            print_hex(i, 2);
            found++;
        }
    }

    if(found == 0) {
        print_string("No devices found");
    }
    print_string("\r\n");
}

/* USER CODE END PFP */

/* External functions --------------------------------------------------------*/
/* USER CODE BEGIN ExternalFunctions */

/* USER CODE END ExternalFunctions */

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
  __HAL_RCC_PWR_CLK_ENABLE();

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);

  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}

/**
  * @brief I2C MSP Initialization
  * This function configures the hardware resources used in this example
  * @param hi2c: I2C handle pointer
  * @retval None
  */
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hi2c->Instance==I2C1)
  {
    /* USER CODE BEGIN I2C1_MspInit 0 */

    /* USER CODE END I2C1_MspInit 0 */

    __HAL_RCC_GPIOB_CLK_ENABLE();
    /**I2C1 GPIO Configuration
    PB8     ------> I2C1_SCL
    PB9     ------> I2C1_SDA
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
    /* USER CODE BEGIN I2C1_MspInit 1 */

    /* USER CODE END I2C1_MspInit 1 */

  }

}

/**
  * @brief I2C MSP De-Initialization
  * This function freeze the hardware resources used in this example
  * @param hi2c: I2C handle pointer
  * @retval None
  */
void HAL_I2C_MspDeInit(I2C_HandleTypeDef* hi2c)
{
  if(hi2c->Instance==I2C1)
  {
    /* USER CODE BEGIN I2C1_MspDeInit 0 */

    /* USER CODE END I2C1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C1_CLK_DISABLE();

    /**I2C1 GPIO Configuration
    PB8     ------> I2C1_SCL
    PB9     ------> I2C1_SDA
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_8);

    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_9);

    /* USER CODE BEGIN I2C1_MspDeInit 1 */

    /* USER CODE END I2C1_MspDeInit 1 */
  }

}

/**
  * @brief UART MSP Initialization
  * This function configures the hardware resources used in this example
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(huart->Instance==USART2)
  {
    /* USER CODE BEGIN USART2_MspInit 0 */

    /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();

    __HAL_RCC_GPIOA_CLK_ENABLE();
    /**USART2 GPIO Configuration
    PA2     ------> USART2_TX
    PA3     ------> USART2_RX
    */
    GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* USER CODE BEGIN USART2_MspInit 1 */

    /* USER CODE END USART2_MspInit 1 */

  }

}

/**
  * @brief UART MSP De-Initialization
  * This function freeze the hardware resources used in this example
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspDeInit(UART_HandleTypeDef* huart)
{
  if(huart->Instance==USART2)
  {
    /* USER CODE BEGIN USART2_MspDeInit 0 */

    /* USER CODE END USART2_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_USART2_CLK_DISABLE();

    /**USART2 GPIO Configuration
    PA2     ------> USART2_TX
    PA3     ------> USART2_RX
    */
    HAL_GPIO_DeInit(GPIOA, USART_TX_Pin|USART_RX_Pin);

    /* USER CODE BEGIN USART2_MspDeInit 1 */

    /* USER CODE END USART2_MspDeInit 1 */
  }

}

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */
