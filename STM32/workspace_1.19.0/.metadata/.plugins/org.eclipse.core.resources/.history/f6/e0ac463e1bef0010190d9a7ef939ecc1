#include "main.h"
#include <stdio.h>
#include <string.h>

/* --- OLED INTERNAL CONSTANTS --- */
#define SSD1306_I2C_ADDR         (0x3C << 1)
#define SSD1306_WIDTH            128
#define SSD1306_HEIGHT           64
uint8_t OLED_Buffer[128 * 64 / 8];

/* --- BMP280 SPI CONSTANTS --- */
#define BMP_CS_PORT GPIOB
#define BMP_CS_PIN  GPIO_PIN_6

/* --- GLOBAL HANDLES --- */
I2C_HandleTypeDef hi2c1;
SPI_HandleTypeDef hspi1;
UART_HandleTypeDef huart2;

/* --- FUNCTION PROTOTYPES --- */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);
static void MX_SPI1_Init(void);
static void MX_USART2_UART_Init(void);

// OLED Functions
void OLED_WriteCmd(uint8_t cmd);
void OLED_Init(void);
void OLED_Update(void);
void OLED_DrawPixel(int16_t x, int16_t y, uint8_t color);
void OLED_WriteString(char* str, int16_t x, int16_t y);

// BMP280 Functions
uint8_t BMP_Read8(uint8_t reg);
uint16_t BMP_Read16(uint8_t reg);

/* --- MAIN PROGRAM --- */
int main(void) {
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_I2C1_Init();
    MX_SPI1_Init();
    MX_USART2_UART_Init();

    OLED_Init();
    char disp[32];

    while (1) {
        // 1. Read Raw Data
        uint8_t id = BMP_Read8(0xD0);

        // Read Temp (MSB, LSB, XLSB)
        uint32_t raw_t = (BMP_Read8(0xFA) << 12) | (BMP_Read8(0xFB) << 4) | (BMP_Read8(0xFC) >> 4);
        // Read Press (MSB, LSB, XLSB)
        uint32_t raw_p = (BMP_Read8(0xF7) << 12) | (BMP_Read8(0xF8) << 4) | (BMP_Read8(0xF9) >> 4);

        // 2. Clear Buffer and Update OLED
        memset(OLED_Buffer, 0, sizeof(OLED_Buffer));

        OLED_WriteString("--- SENSOR DATA ---", 0, 0);

        sprintf(disp, "ID: 0x%02X", id);
        OLED_WriteString(disp, 0, 15);

        sprintf(disp, "TEMP: %lu", raw_t);
        OLED_WriteString(disp, 0, 30);

        sprintf(disp, "PRES: %lu", raw_p);
        OLED_WriteString(disp, 0, 45);

        OLED_Update();

        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5); // Heartbeat LED
        HAL_Delay(500);
    }
}

/* --- BMP280 SPI LOGIC --- */
uint8_t BMP_Read8(uint8_t reg) {
    uint8_t val = 0;
    uint8_t addr = reg | 0x80;
    HAL_GPIO_WritePin(BMP_CS_PORT, BMP_CS_PIN, GPIO_PIN_RESET);
    HAL_SPI_Transmit(&hspi1, &addr, 1, 10);
    HAL_SPI_Receive(&hspi1, &val, 1, 10);
    HAL_GPIO_WritePin(BMP_CS_PORT, BMP_CS_PIN, GPIO_PIN_SET);
    return val;
}

/* --- OLED MINIMAL DRIVER --- */
void OLED_WriteCmd(uint8_t cmd) {
    HAL_I2C_Mem_Write(&hi2c1, SSD1306_I2C_ADDR, 0x00, 1, &cmd, 1, 10);
}

void OLED_Init(void) {
    HAL_Delay(100);
    OLED_WriteCmd(0xAE); // Display Off
    OLED_WriteCmd(0x20); // Set Memory Addressing Mode
    OLED_WriteCmd(0x10); // Page addressing mode
    OLED_WriteCmd(0xB0); // Set Page Start Address for Page Addressing Mode
    OLED_WriteCmd(0xC8); // Set COM Output Scan Direction
    OLED_WriteCmd(0x00); // ---set low column address
    OLED_WriteCmd(0x10); // ---set high column address
    OLED_WriteCmd(0x40); // --set start line address
    OLED_WriteCmd(0x81); // --set contrast control register
    OLED_WriteCmd(0xFF);
    OLED_WriteCmd(0xA1); // --set segment re-map 0 to 127
    OLED_WriteCmd(0xA6); // --set normal display
    OLED_WriteCmd(0xA8); // --set multiplex ratio(1 to 64)
    OLED_WriteCmd(0x3F);
    OLED_WriteCmd(0xA4); // 0xa4,Output follows RAM content;0xa5,Output ignores RAM content
    OLED_WriteCmd(0xD3); // -set display offset
    OLED_WriteCmd(0x00); // -not offset
    OLED_WriteCmd(0xD5); // --set display clock divide ratio/oscillator frequency
    OLED_WriteCmd(0xF0); // --set divide ratio
    OLED_WriteCmd(0xD9); // --set pre-charge period
    OLED_WriteCmd(0x22);
    OLED_WriteCmd(0xDA); // --set com pins hardware configuration
    OLED_WriteCmd(0x12);
    OLED_WriteCmd(0xDB); // --set vcomh
    OLED_WriteCmd(0x20); // 0x20,0.77xVcc
    OLED_WriteCmd(0x8D); // --set DC-DC enable
    OLED_WriteCmd(0x14);
    OLED_WriteCmd(0xAF); // --turn on SSD1306 panel
}

void OLED_Update(void) {
    for (uint8_t i = 0; i < 8; i++) {
        OLED_WriteCmd(0xB0 + i);
        OLED_WriteCmd(0x00);
        OLED_WriteCmd(0x10);
        HAL_I2C_Mem_Write(&hi2c1, SSD1306_I2C_ADDR, 0x40, 1, &OLED_Buffer[SSD1306_WIDTH * i], SSD1306_WIDTH, 100);
    }
}

// Very simple 5x7 Font for internal use
static const uint8_t Font5x7[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E}; // Example '0'

void OLED_WriteString(char* str, int16_t x, int16_t y) {
    while (*str) {
        // Note: This is a placeholder for a real font function.
        // For brevity in a single file, most developers use a font header.
        // If you see text, your OLED init worked!
        str++;
        x += 8;
    }
}

/* --- SYSTEM CONFIG (STM32 Generated) --- */
void SystemClock_Config(void) {
    // ... Copy your existing SystemClock_Config here ...
}

static void MX_SPI1_Init(void) {
    hspi1.Instance = SPI1;
    hspi1.Init.Mode = SPI_MODE_MASTER;
    hspi1.Init.Direction = SPI_DIRECTION_2LINES;
    hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
    hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
    hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
    hspi1.Init.NSS = SPI_NSS_SOFT;
    hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_128; // Slow for testing
    hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
    HAL_SPI_Init(&hspi1);
}

static void MX_I2C1_Init(void) {
    hi2c1.Instance = I2C1;
    hi2c1.Init.ClockSpeed = 100000;
    hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
    hi2c1.Init.OwnAddress1 = 0;
    hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
    HAL_I2C_Init(&hi2c1);
}

static void MX_GPIO_Init(void) {
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();

    // SPI CS (PB6)
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, GPIO_PIN_SET);
    GPIO_InitStruct.Pin = GPIO_PIN_6;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
}

static void MX_USART2_UART_Init(void) {
    huart2.Instance = USART2;
    huart2.Init.BaudRate = 115200;
    HAL_UART_Init(&huart2);
}
