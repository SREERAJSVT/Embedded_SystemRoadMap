/*#include "SGP40SHT4x.h"
#include <stdio.h>

// --- Font Table for OLED (ASCII 32-90) ---
const uint8_t font5x7[][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, // space
    {0x00, 0x00, 0x5F, 0x00, 0x00}, // !
    {0x3E, 0x51, 0x49, 0x45, 0x3E}, // 0 (Index 16)
    {0x00, 0x42, 0x7F, 0x40, 0x00}, // 1
    {0x42, 0x61, 0x51, 0x49, 0x46}, // 2
    {0x21, 0x41, 0x45, 0x4B, 0x31}, // 3
    {0x18, 0x14, 0x12, 0x7F, 0x10}, // 4
    {0x27, 0x45, 0x45, 0x45, 0x39}, // 5
    {0x3C, 0x4A, 0x49, 0x49, 0x30}, // 6
    {0x01, 0x71, 0x09, 0x05, 0x03}, // 7
    {0x36, 0x49, 0x49, 0x49, 0x36}, // 8
    {0x06, 0x49, 0x49, 0x29, 0x1E}, // 9
    {0x00, 0x36, 0x36, 0x00, 0x00}, // :
    {0x7E, 0x11, 0x11, 0x11, 0x7E}, // A (Index 33)
    {0x7F, 0x49, 0x49, 0x49, 0x36}, // B
    {0x3E, 0x41, 0x41, 0x41, 0x22}, // C
    {0x7F, 0x41, 0x41, 0x22, 0x1C}, // D
    {0x7F, 0x49, 0x49, 0x49, 0x41}, // E
    {0x7F, 0x09, 0x09, 0x09, 0x01}, // F
    {0x3E, 0x41, 0x49, 0x49, 0x7A}, // G
    {0x7F, 0x08, 0x08, 0x08, 0x7F}, // H
    {0x00, 0x41, 0x7F, 0x41, 0x00}, // I
    {0x20, 0x40, 0x41, 0x3F, 0x01}, // J
    {0x7F, 0x08, 0x14, 0x22, 0x41}, // K
    {0x7F, 0x40, 0x40, 0x40, 0x40}, // L
    {0x7F, 0x02, 0x0C, 0x02, 0x7F}, // M
    {0x7F, 0x04, 0x08, 0x10, 0x7F}, // N
    {0x3E, 0x41, 0x41, 0x41, 0x3E}, // O
    {0x7F, 0x09, 0x09, 0x09, 0x06}, // P
    {0x3E, 0x41, 0x51, 0x21, 0x5E}, // Q
    {0x7F, 0x09, 0x19, 0x29, 0x46}, // R
    {0x46, 0x49, 0x49, 0x49, 0x31}, // S
    {0x01, 0x01, 0x7F, 0x01, 0x01}, // T
    {0x3F, 0x40, 0x40, 0x40, 0x3F}, // U
    {0x1F, 0x20, 0x40, 0x20, 0x1F}, // V
    {0x3F, 0x40, 0x38, 0x40, 0x3F}, // W
    {0x63, 0x14, 0x08, 0x14, 0x63}, // X
    {0x07, 0x08, 0x70, 0x08, 0x07}, // Y
    {0x61, 0x51, 0x49, 0x45, 0x43}  // Z
};

// --- ITM Redirection for printf ---
#define ITM_Port8(n)    (*(volatile uint8_t *)(0xE0000000 + 4*(n)))
#define ITM_Port32(n)   (*(volatile uint32_t *)(0xE0000000 + 4*(n)))
#define DEMCR           (*(volatile uint32_t *)(0xE000EDFC))
#define TRCENA          (1 << 24)

int _write(int file, char *ptr, int len) {
    for (int i = 0; i < len; i++) {
        if (((DEMCR & TRCENA) != 0) && ((ITM_Port32(0) & 1) != 0)) {
            while (ITM_Port32(0) == 0);
            ITM_Port8(0) = ptr[i];
        }
    }
    return len;
}

// --- Helper Functions ---
void Delay(uint32_t count) {
    for(volatile uint32_t i = 0; i < count * 4000; i++);
}

// --- I2C Low Level ---
void I2C1_Start(void) {
    I2C1_CR1 |= (1 << 8);
    while (!(I2C1_SR1 & (1 << 0)));
}

void I2C1_Address(uint8_t addr) {
    I2C1_DR = addr;
    while (!(I2C1_SR1 & (1 << 1)));
    (void)I2C1_SR1; (void)I2C1_SR2;
}

void I2C1_Write(uint8_t data) {
    while (!(I2C1_SR1 & (1 << 7)));
    I2C1_DR = data;
}

uint8_t I2C1_ReadAck(void) {
    I2C1_CR1 |= (1 << 10);
    while (!(I2C1_SR1 & (1 << 6)));
    return (uint8_t)I2C1_DR;
}

uint8_t I2C1_ReadNack(void) {
    I2C1_CR1 &= ~(1 << 10);
    I2C1_CR1 |= (1 << 9);
    while (!(I2C1_SR1 & (1 << 6)));
    return (uint8_t)I2C1_DR;
}

void I2C1_Stop(void) {
    I2C1_CR1 |= (1 << 9);
}

// --- OLED Functions ---
void OLED_WriteCmd(uint8_t cmd) {
    I2C1_Start();
    I2C1_Address(OLED_ADDR << 1);
    I2C1_Write(0x00);
    I2C1_Write(cmd);
    I2C1_Stop();
}

void OLED_SetCursor(uint8_t page, uint8_t col) {
    OLED_WriteCmd(0xB0 + page);
    OLED_WriteCmd(0x00 + (col & 0x0F));
    OLED_WriteCmd(0x10 + (col >> 4));
}

void OLED_PutChar(char c) {
    if (c < 32 || c > 90) c = 32;
    const uint8_t *glyph = font5x7[c - 32];
    I2C1_Start();
    I2C1_Address(OLED_ADDR << 1);
    I2C1_Write(0x40);
    for(int i=0; i<5; i++) I2C1_Write(glyph[i]);
    I2C1_Write(0x00);
    I2C1_Stop();
}

void OLED_PutString(char *s) {
    while (*s) OLED_PutChar(*s++);
}

void OLED_Init(void) {
    Delay(100);
    OLED_WriteCmd(0xAE); OLED_WriteCmd(0xA8); OLED_WriteCmd(0x1F);
    OLED_WriteCmd(0x8D); OLED_WriteCmd(0x14); OLED_WriteCmd(0xAF);
}

void OLED_Clear(void) {
    for(uint8_t p=0; p<4; p++) {
        OLED_SetCursor(p, 0);
        I2C1_Start(); I2C1_Address(OLED_ADDR << 1);
        I2C1_Write(0x40);
        for(int i=0; i<128; i++) I2C1_Write(0x00);
        I2C1_Stop();
    }
}

// --- Sensor Logic ---
void SHT4x_ReadRaw(uint16_t *t) {
    I2C1_Start(); I2C1_Address(SHT4X_ADDR << 1);
    I2C1_Write(0xFD); I2C1_Stop();
    Delay(10);
    I2C1_Start(); I2C1_Address((SHT4X_ADDR << 1)|1);
    *t = (I2C1_ReadAck() << 8) | I2C1_ReadAck();
    (void)I2C1_ReadNack();
}

void SGP40_ReadRaw(uint16_t *v) {
    I2C1_Start(); I2C1_Address(SGP40_ADDR << 1);
    I2C1_Write(0x26); I2C1_Write(0x0F); I2C1_Stop();
    Delay(30);
    I2C1_Start(); I2C1_Address((SGP40_ADDR << 1)|1);
    *v = (I2C1_ReadAck() << 8) | I2C1_ReadAck();
    (void)I2C1_ReadNack();
}

void System_Init(void) {
    RCC_AHB1ENR |= (1 << 0) | (1 << 1); // GPIOA, GPIOB
    RCC_APB1ENR |= (1 << 17) | (1 << 21); // USART2, I2C1

    GPIOB_MODER  |= (2 << 16) | (2 << 18); // AF Mode PB8, PB9
    GPIOB_OTYPER |= (1 << 8) | (1 << 9);   // Open Drain
    GPIOB_PUPDR  |= (1 << 16) | (1 << 18); // Pullups
    GPIOB_AFRH   |= (4 << 0) | (4 << 4);   // AF4

    I2C1_CR2 = 16; I2C1_CCR = 80; I2C1_TRISE = 17;
    I2C1_CR1 |= 1;
}

int main(void) {
    System_Init();
    OLED_Init();
    OLED_Clear();

    uint16_t tr, vr;
    char buf[20];

    while(1) {
        SHT4x_ReadRaw(&tr);
        SGP40_ReadRaw(&vr);

        // This goes to SWV ITM Console
        printf("SHT:%u | SGP:%u\n", tr, vr);

        // This goes to OLED
        OLED_SetCursor(0, 0);
        sprintf(buf, "TEMP_RAW:%u", tr);
        OLED_PutString(buf);

        OLED_SetCursor(2, 0);
        sprintf(buf, "VOC_RAW:%u", vr);
        OLED_PutString(buf);

        Delay(1000);
    }
}*/
#include <stdint.h>
#include <stdio.h>

// --- Register Definitions (STM32F446RE) ---
#define RCC_BASE      0x40023800
#define GPIOB_BASE    0x40020400
#define I2C1_BASE     0x40005400

#define RCC_AHB1ENR   (*(volatile uint32_t *)(RCC_BASE + 0x30))
#define RCC_APB1ENR   (*(volatile uint32_t *)(RCC_BASE + 0x40))
#define GPIOB_MODER   (*(volatile uint32_t *)(GPIOB_BASE + 0x00))
#define GPIOB_OTYPER  (*(volatile uint32_t *)(GPIOB_BASE + 0x04))
#define GPIOB_PUPDR   (*(volatile uint32_t *)(GPIOB_BASE + 0x0C))
#define GPIOB_AFRH    (*(volatile uint32_t *)(GPIOB_BASE + 0x24))

#define I2C1_CR1      (*(volatile uint32_t *)(I2C1_BASE + 0x00))
#define I2C1_CR2      (*(volatile uint32_t *)(I2C1_BASE + 0x04))
#define I2C1_DR       (*(volatile uint32_t *)(I2C1_BASE + 0x10))
#define I2C1_SR1      (*(volatile uint32_t *)(I2C1_BASE + 0x14))
#define I2C1_SR2      (*(volatile uint32_t *)(I2C1_BASE + 0x18))
#define I2C1_CCR      (*(volatile uint32_t *)(I2C1_BASE + 0x1C))
#define I2C1_TRISE    (*(volatile uint32_t *)(I2C1_BASE + 0x20))

#define OLED_ADDR     0x3C

// --- ITM Redirection for printf ---
#define ITM_Port8(n)    (*(volatile uint8_t *)(0xE0000000 + 4*(n)))
#define ITM_Port32(n)   (*(volatile uint32_t *)(0xE0000000 + 4*(n)))
#define DEMCR           (*(volatile uint32_t *)(0xE000EDFC))
#define TRCENA          (1 << 24)

int _write(int file, char *ptr, int len) {
    for (int i = 0; i < len; i++) {
        if (((DEMCR & TRCENA) != 0) && ((ITM_Port32(0) & 1) != 0)) {
            while (ITM_Port32(0) == 0);
            ITM_Port8(0) = ptr[i];
        }
    }
    return len;
}

// --- Low-Level I2C Functions ---
void I2C1_Start(void) {
    I2C1_CR1 |= (1 << 8); // Generate START
    while (!(I2C1_SR1 & (1 << 0))); // Wait for SB
}

void I2C1_Address(uint8_t addr) {
    I2C1_DR = addr;
    while (!(I2C1_SR1 & (1 << 1))); // Wait for ADDR
    (void)I2C1_SR1; (void)I2C1_SR2; // Clear ADDR flag
}

void I2C1_Write(uint8_t data) {
    while (!(I2C1_SR1 & (1 << 7))); // Wait for TXE
    I2C1_DR = data;
}

void I2C1_Stop(void) {
    I2C1_CR1 |= (1 << 9); // Generate STOP
}

// --- Basic OLED Functions ---
void OLED_Cmd(uint8_t cmd) {
    I2C1_Start();
    I2C1_Address(OLED_ADDR << 1);
    I2C1_Write(0x00); // Command mode
    I2C1_Write(cmd);
    I2C1_Stop();
}

void OLED_Init(void) {
    for(volatile int i=0; i<50000; i++); // Startup delay
    OLED_Cmd(0xAE); // Display OFF
    OLED_Cmd(0x8D); OLED_Cmd(0x14); // Enable Charge Pump
    OLED_Cmd(0xAF); // Display ON
}

void OLED_Fill(uint8_t pattern) {
    for (uint8_t p = 0; p < 8; p++) {
        OLED_Cmd(0xB0 + p); // Set Page
        OLED_Cmd(0x00);     // Set Column Low
        OLED_Cmd(0x10);     // Set Column High
        I2C1_Start();
        I2C1_Address(OLED_ADDR << 1);
        I2C1_Write(0x40);   // Data mode
        for (int i = 0; i < 128; i++) I2C1_Write(pattern);
        I2C1_Stop();
    }
}

// --- System Initialization ---
void System_Init(void) {
    RCC_AHB1ENR |= (1 << 1);  // Enable GPIOB clock
    RCC_APB1ENR |= (1 << 21); // Enable I2C1 clock

    // Configure PB8 (SCL) and PB9 (SDA) as AF4
    GPIOB_MODER |= (2 << 16) | (2 << 18);
    GPIOB_OTYPER |= (1 << 8) | (1 << 9);
    GPIOB_PUPDR |= (1 << 16) | (1 << 18);
    GPIOB_AFRH |= (4 << 0) | (4 << 4);

    // I2C1 Timing for 16MHz Clock
    I2C1_CR2 = 16;     // 16 MHz Clock
    I2C1_CCR = 80;     // 100 kHz Standard Mode
    I2C1_TRISE = 17;   // Max Rise Time
    I2C1_CR1 |= 1;     // Enable I2C
}

int main(void) {
    System_Init();
    printf("OLED Check Starting...\n");

    OLED_Init();

    // Pattern 1: Solid White (Verify every pixel)
    OLED_Fill(0xFF);
    for(volatile int i=0; i<2000000; i++);

    // Pattern 2: Stripes (Verify data integrity)
    OLED_Fill(0xAA);
    for(volatile int i=0; i<2000000; i++);

    // Clear screen
    OLED_Fill(0x00);
    printf("OLED Check Complete.\n");

    while(1);
}
