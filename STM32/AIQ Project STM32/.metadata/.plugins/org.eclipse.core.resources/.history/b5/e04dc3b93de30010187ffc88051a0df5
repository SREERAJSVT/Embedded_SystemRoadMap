#include "SGP40SHT4x.h"
#include <stdio.h>

void Delay(uint32_t count) {
    for(volatile uint32_t i = 0; i < count * 4000; i++);
}

// --- UART & I2C Core Functions ---
void UART2_SendString(char *s) {
    while (*s) {
        while (!(USART2_SR & (1 << 7)));
        USART2_DR = *s++;
    }
}

void I2C1_Start(void) {
    I2C1_CR1 |= (1 << 8);
    while (!(I2C1_SR1 & (1 << 0)));
}

void I2C1_Address(uint8_t addr) {
    I2C1_DR = addr;
    while (!(I2C1_SR1 & (1 << 1)));
    (void)I2C1_SR1; (void)I2C1_SR2; // Clear ADDR flag
}

void I2C1_Write(uint8_t data) {
    while (!(I2C1_SR1 & (1 << 7)));
    I2C1_DR = data;
}

uint8_t I2C1_ReadAck(void) {
    I2C1_CR1 |= (1 << 10);
    while (!(I2C1_SR1 & (1 << 6)));
    return (uint8_t)I2C1_DR;
}

uint8_t I2C1_ReadNack(void) {
    I2C1_CR1 &= ~(1 << 10);
    I2C1_CR1 |= (1 << 9); // Stop bit
    while (!(I2C1_SR1 & (1 << 6)));
    return (uint8_t)I2C1_DR;
}

void I2C1_Stop(void) {
    I2C1_CR1 |= (1 << 9);
}

// --- Initialization ---
void System_Init(void) {
    // 1. Enable Peripheral Clocks
    RCC_AHB1ENR |= (1 << 0) | (1 << 1); // GPIOA and GPIOB
    RCC_APB1ENR |= (1 << 17) | (1 << 21); // USART2 and I2C1

    // 2. UART2 Config (PA2=TX, PA3=RX) AF7
    GPIOA_MODER |= (2 << 4) | (2 << 6);
    GPIOA_AFRL |= (7 << 8) | (7 << 12);
    USART2_BRR = 0x683; // 9600 Baud @ 16MHz
    USART2_CR1 |= (1 << 3) | (1 << 13);

    // 3. I2C1 Config (PB8=SCL, PB9=SDA) AF4
    GPIOB_MODER |= (2 << 16) | (2 << 18);
    GPIOB_OTYPER |= (1 << 8) | (1 << 9);
    GPIOB_PUPDR |= (1 << 16) | (1 << 18);
    GPIOB_AFRH |= (4 << 0) | (4 << 4);
    I2C1_CR2 = 16;   // 16MHz
    I2C1_CCR = 80;   // 100kHz
    I2C1_TRISE = 17;
    I2C1_CR1 |= 1;
}

// --- OLED Logic ---
void OLED_WriteCmd(uint8_t cmd) {
    I2C1_Start();
    I2C1_Address(OLED_ADDR << 1);
    I2C1_Write(0x00);
    I2C1_Write(cmd);
    I2C1_Stop();
}

void OLED_Init(void) {
    OLED_WriteCmd(0xAE); // Off
    OLED_WriteCmd(0xA8); OLED_WriteCmd(0x1F); // Ratio 32
    OLED_WriteCmd(0x8D); OLED_WriteCmd(0x14); // Charge pump
    OLED_WriteCmd(0xAF); // On
}

void OLED_Clear(void) {
    for(uint8_t p=0; p<4; p++) {
        OLED_WriteCmd(0xB0 + p);
        OLED_WriteCmd(0x00); OLED_WriteCmd(0x10);
        I2C1_Start();
        I2C1_Address(OLED_ADDR << 1);
        I2C1_Write(0x40);
        for(uint8_t i=0; i<128; i++) I2C1_Write(0x00);
        I2C1_Stop();
    }
}

// --- Sensor Reads ---
void SHT4x_ReadRaw(uint16_t *temp) {
    I2C1_Start();
    I2C1_Address(SHT4X_ADDR << 1);
    I2C1_Write(0xFD);
    I2C1_Stop();
    Delay(10);
    I2C1_Start();
    I2C1_Address((SHT4X_ADDR << 1) | 1);
    *temp = (I2C1_ReadAck() << 8) | I2C1_ReadAck();
    (void)I2C1_ReadNack(); // CRC
}

void SGP40_ReadRaw(uint16_t *voc) {
    I2C1_Start();
    I2C1_Address(SGP40_ADDR << 1);
    I2C1_Write(0x26); I2C1_Write(0x0F);
    I2C1_Stop();
    Delay(30);
    I2C1_Start();
    I2C1_Address((SGP40_ADDR << 1) | 1);
    *voc = (I2C1_ReadAck() << 8) | I2C1_ReadAck();
    (void)I2C1_ReadNack(); // CRC
}
// Set the cursor position on the OLED
void OLED_SetCursor(uint8_t page, uint8_t column) {
    OLED_WriteCmd(0xB0 + page);             // Set Page
    OLED_WriteCmd(0x00 + (column & 0x0F));  // Set Low Column
    OLED_WriteCmd(0x10 + (column >> 4));    // Set High Column
}

// Write a single character
void OLED_PutChar(char c) {
    if (c < 32 || c > 90) c = 32; // Boundary check
    const uint8_t *glyph = font5x7[c - 32];

    I2C1_Start();
    I2C1_Address(OLED_ADDR << 1);
    I2C1_Write(0x40); // Data mode
    for (int i = 0; i < 5; i++) {
        I2C1_Write(glyph[i]);
    }
    I2C1_Write(0x00); // 1px space between chars
    I2C1_Stop();
}

// Write a string
void OLED_PutString(char *s) {
    while (*s) OLED_PutChar(*s++);
}

int main(void) {
    System_Init();
    OLED_Init();
    OLED_Clear();

    char buf[64];
    uint16_t t_raw, v_raw;

    UART2_SendString("AIQ Monitor Active\r\n");

    while (1) {
        SHT4x_ReadRaw(&t_raw);
        SGP40_ReadRaw(&v_raw);

        sprintf(buf, "TEMP_RAW: %u | VOC_RAW: %u\r\n", t_raw, v_raw);
        UART2_SendString(buf);

        // OLED display of raw values usually requires a font map.
        // For now, these are confirmed on UART.
        Delay(1000);
    }
}
