#include "SGP40SHT4x.h"
#include <stdio.h>

// --- Minimal Font Table (ASCII 32-90) ---
// Each character is 5 bytes wide (5x7 pixels)
const uint8_t font5x7[][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, // space
    {0x00, 0x00, 0x5F, 0x00, 0x00}, // !
    {0x00, 0x07, 0x00, 0x07, 0x00}, // "
    {0x14, 0x7F, 0x14, 0x7F, 0x14}, // #
    {0x24, 0x2A, 0x7F, 0x2A, 0x12}, // $
    {0x23, 0x13, 0x08, 0x64, 0x62}, // %
    {0x36, 0x49, 0x55, 0x22, 0x50}, // &
    {0x00, 0x05, 0x03, 0x00, 0x00}, // '
    {0x00, 0x1C, 0x22, 0x41, 0x00}, // (
    {0x00, 0x41, 0x22, 0x1C, 0x00}, // )
    {0x14, 0x08, 0x3E, 0x08, 0x14}, // *
    {0x08, 0x08, 0x3E, 0x08, 0x08}, // +
    {0x00, 0x50, 0x30, 0x00, 0x00}, // ,
    {0x08, 0x08, 0x08, 0x08, 0x08}, // -
    {0x00, 0x60, 0x60, 0x00, 0x00}, // .
    {0x20, 0x10, 0x08, 0x04, 0x02}, // /
    {0x3E, 0x51, 0x49, 0x45, 0x3E}, // 0
    {0x00, 0x42, 0x7F, 0x40, 0x00}, // 1
    {0x42, 0x61, 0x51, 0x49, 0x46}, // 2
    {0x21, 0x41, 0x45, 0x4B, 0x31}, // 3
    {0x18, 0x14, 0x12, 0x7F, 0x10}, // 4
    {0x27, 0x45, 0x45, 0x45, 0x39}, // 5
    {0x3C, 0x4A, 0x49, 0x49, 0x30}, // 6
    {0x01, 0x71, 0x09, 0x05, 0x03}, // 7
    {0x36, 0x49, 0x49, 0x49, 0x36}, // 8
    {0x06, 0x49, 0x49, 0x29, 0x1E}, // 9
    {0x00, 0x36, 0x36, 0x00, 0x00}, // :
    {0x00, 0x56, 0x36, 0x00, 0x00}, // ;
    {0x08, 0x14, 0x22, 0x41, 0x00}, // <
    {0x24, 0x24, 0x24, 0x24, 0x24}, // =
    {0x00, 0x41, 0x22, 0x14, 0x08}, // >
    {0x02, 0x01, 0x51, 0x09, 0x06}, // ?
    {0x32, 0x49, 0x79, 0x41, 0x3E}, // @
    {0x7E, 0x11, 0x11, 0x11, 0x7E}, // A
    {0x7F, 0x49, 0x49, 0x49, 0x36}, // B
    {0x3E, 0x41, 0x41, 0x41, 0x22}, // C
    {0x7F, 0x41, 0x41, 0x22, 0x1C}, // D
    {0x7F, 0x49, 0x49, 0x49, 0x41}, // E
    {0x7F, 0x09, 0x09, 0x09, 0x01}, // F
    {0x3E, 0x41, 0x49, 0x49, 0x7A}, // G
    {0x7F, 0x08, 0x08, 0x08, 0x7F}, // H
    {0x00, 0x41, 0x7F, 0x41, 0x00}, // I
    {0x20, 0x40, 0x41, 0x3F, 0x01}, // J
    {0x7F, 0x08, 0x14, 0x22, 0x41}, // K
    {0x7F, 0x40, 0x40, 0x40, 0x40}, // L
    {0x7F, 0x02, 0x0C, 0x02, 0x7F}, // M
    {0x7F, 0x04, 0x08, 0x10, 0x7F}, // N
    {0x3E, 0x41, 0x41, 0x41, 0x3E}, // O
    {0x7F, 0x09, 0x09, 0x09, 0x06}, // P
    {0x3E, 0x41, 0x51, 0x21, 0x5E}, // Q
    {0x7F, 0x09, 0x19, 0x29, 0x46}, // R
    {0x46, 0x49, 0x49, 0x49, 0x31}, // S
    {0x01, 0x01, 0x7F, 0x01, 0x01}, // T
    {0x3F, 0x40, 0x40, 0x40, 0x3F}, // U
    {0x1F, 0x20, 0x40, 0x20, 0x1F}, // V
    {0x3F, 0x40, 0x38, 0x40, 0x3F}, // W
    {0x63, 0x14, 0x08, 0x14, 0x63}, // X
    {0x07, 0x08, 0x70, 0x08, 0x07}, // Y
    {0x61, 0x51, 0x49, 0x45, 0x43}  // Z
};

// --- Delay & UART ---
void Delay(uint32_t count) {
    for(volatile uint32_t i = 0; i < count * 4000; i++);
}

void UART2_SendString(char *s) {
    while (*s) {
        while (!(USART2_SR & (1 << 7)));
        USART2_DR = *s++;
    }
}

// --- I2C Core Implementation ---
void I2C1_Start(void) {
    I2C1_CR1 |= (1 << 8);
    while (!(I2C1_SR1 & (1 << 0)));
}

void I2C1_Address(uint8_t addr) {
    I2C1_DR = addr;
    while (!(I2C1_SR1 & (1 << 1)));
    (void)I2C1_SR1; (void)I2C1_SR2;
}

void I2C1_Write(uint8_t data) {
    while (!(I2C1_SR1 & (1 << 7)));
    I2C1_DR = data;
}

uint8_t I2C1_ReadAck(void) {
    I2C1_CR1 |= (1 << 10);
    while (!(I2C1_SR1 & (1 << 6)));
    return (uint8_t)I2C1_DR;
}

uint8_t I2C1_ReadNack(void) {
    I2C1_CR1 &= ~(1 << 10);
    I2C1_CR1 |= (1 << 9);
    while (!(I2C1_SR1 & (1 << 6)));
    return (uint8_t)I2C1_DR;
}

void I2C1_Stop(void) {
    I2C1_CR1 |= (1 << 9);
}

// --- OLED Rendering ---
void OLED_WriteCmd(uint8_t cmd) {
    I2C1_Start();
    I2C1_Address(OLED_ADDR << 1);
    I2C1_Write(0x00);
    I2C1_Write(cmd);
    I2C1_Stop();
}

void OLED_SetCursor(uint8_t page, uint8_t col) {
    OLED_WriteCmd(0xB0 + page);
    OLED_WriteCmd(0x00 + (col & 0x0F));
    OLED_WriteCmd(0x10 + (col >> 4));
}

void OLED_PutChar(char c) {
    if (c < 32 || c > 90) c = 32;
    const uint8_t *glyph = font5x7[c - 32];
    I2C1_Start();
    I2C1_Address(OLED_ADDR << 1);
    I2C1_Write(0x40);
    for(int i=0; i<5; i++) I2C1_Write(glyph[i]);
    I2C1_Write(0x00); // 1px spacing
    I2C1_Stop();
}

void OLED_PutString(char *s) {
    while (*s) OLED_PutChar(*s++);
}

void OLED_Init(void) {
    Delay(100);
    OLED_WriteCmd(0xAE); OLED_WriteCmd(0xA8); OLED_WriteCmd(0x1F);
    OLED_WriteCmd(0x8D); OLED_WriteCmd(0x14); OLED_WriteCmd(0xAF);
}

void OLED_Clear(void) {
    for(uint8_t p=0; p<4; p++) {
        OLED_SetCursor(p, 0);
        I2C1_Start();
        I2C1_Address(OLED_ADDR << 1);
        I2C1_Write(0x40);
        for(int i=0; i<128; i++) I2C1_Write(0x00);
        I2C1_Stop();
    }
}

// --- Sensor Logic ---
void SHT4x_ReadRaw(uint16_t *t) {
    I2C1_Start(); I2C1_Address(SHT4X_ADDR << 1);
    I2C1_Write(0xFD); I2C1_Stop();
    Delay(10);
    I2C1_Start(); I2C1_Address((SHT4X_ADDR << 1)|1);
    *t = (I2C1_ReadAck() << 8) | I2C1_ReadAck();
    (void)I2C1_ReadNack();
}

void SGP40_ReadRaw(uint16_t *v) {
    I2C1_Start(); I2C1_Address(SGP40_ADDR << 1);
    I2C1_Write(0x26); I2C1_Write(0x0F); I2C1_Stop();
    Delay(30);
    I2C1_Start(); I2C1_Address((SGP40_ADDR << 1)|1);
    *v = (I2C1_ReadAck() << 8) | I2C1_ReadAck();
    (void)I2C1_ReadNack();
}

// --- Main Entry ---
int main(void) {
    // You MUST include your GPIO/RCC Init here for pins PB8, PB9, PA2, PA3
    // System_Init() function from previous steps...

    OLED_Init();
    OLED_Clear();

    uint16_t tr, vr;
    char buf[20];

    while(1) {
        SHT4x_ReadRaw(&tr);
        SGP40_ReadRaw(&vr);

        OLED_SetCursor(0, 0);
        sprintf(buf, "T_RAW:%u", tr);
        OLED_PutString(buf);

        OLED_SetCursor(2, 0);
        sprintf(buf, "V_RAW:%u", vr);
        OLED_PutString(buf);

        UART2_SendString(buf);
        UART2_SendString("\r\n");
        Delay(1000);
    }
}
