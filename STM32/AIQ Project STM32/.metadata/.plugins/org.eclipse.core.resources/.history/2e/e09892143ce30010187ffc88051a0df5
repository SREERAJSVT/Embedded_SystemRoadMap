/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "SGP40SHT4x.h"

// Reads one byte and sends an ACK (use this for all bytes except the last one)
uint8_t I2C1_ReadAck(void) {
    I2C1_CR1 |= (1 << 10);  // Set ACK bit
    while (!(I2C1_SR1 & (1 << 6))); // Wait for RXNE (Receive Buffer Not Empty)
    return (uint8_t)I2C1_DR;
}

// Reads the final byte and sends a NACK (signals the end of the transfer)
uint8_t I2C1_ReadNack(void) {
    I2C1_CR1 &= ~(1 << 10); // Clear ACK bit (sends NACK)
    I2C1_CR1 |= (1 << 9);   // Generate Stop condition
    while (!(I2C1_SR1 & (1 << 6))); // Wait for RXNE
    return (uint8_t)I2C1_DR;
}

void Delay(uint32_t count) {
    for(uint32_t i = 0; i < count * 1000; i++) __asm("nop");
}

void I2C1_Init(void) {
    // 1. Enable Clock for GPIOB and I2C1
    RCC_AHB1ENR |= (1 << 1);  // GPIOB EN
    RCC_APB1ENR |= (1 << 21); // I2C1 EN

    // 2. Configure PB8(SCL) and PB9(SDA) as Alt Function, Open Drain
    GPIOB_MODER |= (2 << 16) | (2 << 18);     // AF Mode
    GPIOB_OTYPER |= (1 << 8) | (1 << 9);      // Open Drain
    GPIOB_PUPDR |= (1 << 16) | (1 << 18);     // Pull-up
    GPIOB_AFRL |= (4 << 0); // Note: Simplified, check AFRH for pins 8/9

    // 3. I2C Reset and Configuration
    I2C1_CR1 |= (1 << 15); // Software Reset
    I2C1_CR1 &= ~(1 << 15);

    I2C1_CR2 = 16;         // 16MHz Peripheral Clock
    I2C1_CCR = 80;         // 100kHz (16MHz / (2 * 100kHz))
    I2C1_TRISE = 17;       // Maximum rise time
    I2C1_CR1 |= 1;         // Enable PE (Peripheral Enable)
}

// Low-level I2C sequence to read SHT4x
void Read_SHT4x_Raw(uint16_t *temp_raw) {
    I2C1_Start();
    I2C1_Address(SHT4X_ADDR << 1); // Write mode
    I2C1_Write(0xFD);              // High precision command
    I2C1_Stop();

    Delay(20); // Wait for measurement

    I2C1_Start();
    I2C1_Address((SHT4X_ADDR << 1) | 1); // Read mode
    uint8_t msb = I2C1_ReadAck();
    uint8_t lsb = I2C1_ReadAck();
    uint8_t crc = I2C1_ReadNack();
    I2C1_Stop();

    *temp_raw = (msb << 8) | lsb;
}

int main(void) {
    I2C1_Init();
    uint16_t t_raw;

    while(1) {
        Read_SHT4x_Raw(&t_raw);
        // Process t_raw for OLED display logic here
        Delay(1000);
    }
}

// Minimal I2C helpers
void I2C1_Start(void) {
    I2C1_CR1 |= (1 << 8);
    while(!(I2C1_SR1 & (1 << 0))); // Wait for SB
}

void I2C1_Write(uint8_t data) {
    I2C1_DR = data;
    while(!(I2C1_SR1 & (1 << 7))); // Wait for TXE
}

void I2C1_Address(uint8_t addr) {
    I2C1_DR = addr;
    while(!(I2C1_SR1 & (1 << 1))); // Wait for ADDR
    (void)I2C1_SR2;                // Clear ADDR flag
}

void I2C1_Stop(void) {
    I2C1_CR1 |= (1 << 9);
}
